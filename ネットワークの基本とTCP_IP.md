# ネットワークの基本とTCP/IPの仕組み

## TCP/IPとは
TCP/IP(Transmission Control Protocol / Internet Protocol)は、世界的に広く利用されているインターネットプロトコルであり、通信プロトコルの総称。  

このプロトコルは、インターネットやその他のネットワーク上でデータの送受信を管理し、異なるコンピュータやネットワーク機器間での情報交換を可能にする。  

## プロトコルとは
コンピュータ同士がネットワークを通じて通信するために決められた「ルールや手順」のこと。同じプロトコルを使用することで、異なるコンピュータ同士でも通信が可能になるが、異なるプロトコルを使用するコンピュータ同士では通信ができない。  

例えば、言語のプロトコルがあるとすると、日本語(プロトコル)を使用する人とイタリア語(プロトコル)を使用する人では、言語(プロトコル)が異なるため会話内容を理解することができないが、同じ言語(プロトコル)を使用している人同士であれば意思疎通が可能となる。  

コンピュータの場合、人間のように応用力や知能を使って柔軟に対応することができない。そのため、通信を行うには、全ての細かな部分において**明確なルール**が必要となる。  

このような**ルールの集合体がプロトコル**と呼ばれる。  

## 階層モデルとは
通信を改装に分けることで、各層が独立して特定の役割を持てる。例えば1つの層ではデータを物理的に転送し、別の層では送受信されるデータの内容を扱う、といったように役割が明確に分かれている。  

代表的な階層モデルにはTCP/IPモデルとOSI参照モデルがある。
<table border="1">
  <thead>
    <tr>
      <th colspan="2">OSI参照モデル</th>
      <th>TCP/IP</th>
      <th>主なプロトコル、規格</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>第7層</td>
      <td>アプリケーション層</td>
      <td rowspan="3">アプリケーション層</td>
      <td rowspan="3">DNS, HTTP, TLS/SSL, SMTP, POP, IMAP, SSH, FTP, SFTP等</td>
    </tr>
    <tr>
      <td>第6層</td>
      <td>プレゼンテーション層</td>
    </tr>
    <tr>
      <td>第5層</td>
      <td>セッション層</td>
    </tr>
    <tr>
      <td>第4層</td>
      <td>トランスポート層</td>
      <td>トランスポート層</td>
      <td>TCP, UDP等</td>
    </tr>
    <tr>
      <td>第3層</td>
      <td>ネットワーク層</td>
      <td>インターネット層</td>
      <td>IP, ICMP(ping)等, (ARP)</td>
    </tr>
    <tr>
      <td>第2層</td>
      <td>データリンク層</td>
      <td rowspan="2">リンク層 (ネットワークインターフェース層)</td>
      <td rowspan="2">(ARP), PPP, Wi-Fi(IEEE 802.11), Ethenet(IEEE 802.3), MAC等</td>
    </tr>
    <tr>
      <td>第1層</td>
      <td>物理層</td>
    </tr>
  </tbody>
</table>
※　主なプロトコル、規格の詳細については各層の説明にて記載

## 1. アプリケーション層
### 役割
- ユーザーインターフェースの提供：  
    アプリケーション層は、ユーザーとネットワークをつなぐ役割を持っている。つまり、ユーザーがインターネットや他のネットワークリソースを利用できるようにする層。  
    
    この層は、Webブラウザ、メールクライアント、ファイル転送アプリケーションなど、エンドユーザーが直接触れる部分。

- プロトコルの選定と動作：  
    アプリケーション層では、目的に応じたプロトコル(HTTP, SMTP, DNSなど)を選び、そのプロトコルに従って通信を行う。  
    
    例えば、webページのリクエストはHTTPが、メールの送信にはSMTPが使われる。  

- データのフォーマットと処理：  
    データはアプリケーション層で処理され、特定のフォーマット(HTML, JSON, XMLなど)に変換される。   
    
    webページを表示する際にはHTMLデータが処理され、表示される。

### 主なプロトコル、規格
- **DNS(Domain Name System)：**  
    DNSは、インターネット上で使われるドメイン名とIPアドレスを対応付けるシステム。  
    
    例えば、`www.example.com`と入力すると、DNSがそれをIPアドレス(192.168.1.1など)に変換する。  
    
    これにより、ユーザーはIPアドレスではなくドメイン名を使ってWebサイトにアクセスできる.  

- **HTTP(HyperText Transfer Protocol)：**  
    HTTPは、WebサーバーとWebブラウザ(クライアント)間でデータをやり取りするためのプロトコル。  
    
    Webページを表示するために、ブラウザがHTTPリクエストをサーバーに送信し、サーバーがHTMLなどのデータを返すという仕組み。  
    
    ポート番号は80番を使用する。  

- **TLS/SSL(Transport Layer Security / Secure Sockets Layer)：**  
    HTTP通信を安全に行うためのプロトコルで、データの暗号化を行う。  
    
    SSLは古いバージョンで、TLSが新しいバージョンHTTPと組み合わせて使われる場合はHTTPSとなり、Webページが暗号化されることで、  
    外部からのデータ盗聴や改竄を防ぐことができる。  
    
    ポート番号は443番を使用する。

- **HTTPS(HyperText Transfer Protocol Secure)：**
    HTTPSは、HTTPにTLS/SSLによる暗号化を追加したプロトコルで、通信が暗号化され、盗聴や改竄のリスクが減少する。  
    
    HTTPSは、銀行やショッピングサイトなど、機密データのやり取りを行うWebサイトで使われる。  
    
    ポート番号はTLS/SSLと同じく443番を使用する。

- **SMTP(Simple Mail Transfer Protocol)：**  
    SMTPは、メールを送信するためのプロトコル。クライアントからメールサーバーへ、またはサーバー間でメールを転送する役割を持つ。  
    
    基本的に送信専用なので、受信にはPOPやIMAPなど別のプロトコルが使われる。  
    
    ポート番号は25番（暗号化なし）、または587番（暗号化あり）を使用する。
    
- **POP(Post Office Protocol)：**  
    POPは、メールをサーバーからローカルデバイスにダウンロードするためのプロトコル。  
    
    一度ダウンロードすると、そのメールはサーバーから削除されるのが特徴。(POP3が一般的)。  
    
    ポート番号は110番、または995番(暗号化)を使用する。

- **IMAP(Internet Message Access Protocol)：**  
    IMAPは、メールをサーバー上に残しつつ、複数のデバイスからアクセスできるプロトコル。  
    POPとは異なり、メールはサーバーに保存され続けるため、スマートフォンやPCなど複数のデバイスで同期した状態でメールを確認できる。  
    ポート番号は143番、または993番(暗号化)を使用する。

- **SSH(Secure Shell)：**  
    SSHは、リモートコンピュータに安全に接続して操作するためのプロトコル。  
    
    セキュリティが強化されている、データの暗号化や認証機能を持つため、サーバー管理やプログラミングの際に使われる。  
    
    Telnetと異なり、データが暗号化されているため安全。  
    
    ポート番号は22番を使用する。

- **FTP(File Transfer Protocol)：**  
    FTPは、ファイルをサーバーとクライアント間で転送するためのプロトコルだが、データが暗号化されないため、セキュリティ上のリスクがある。  
    
    ポート番号は20番と21番を使用する。

- **SFTP(SSH File Transfer Protool)：**  
    SFTPは、SSHを利用して安全にファイルを転送するプロトコル。  
    
    FTPに比べてデータが暗号化されているため、より安全にファイルをやり取りできる。  
    
    ポート番号はSSHと同じく22番を使用する。

### 具体的なプロセス例
- ### **HTTPSリクエスト**  
    HTTPSで暗号化されたリクエストとレスポンスの動きを確認する。  
    
    `https:google.com`に`curl`コマンドを使ってリクエストを送信し、サーバーとの安全な通信の流れを見てみる。  

    #### 1. リクエストの送信
    `curl`はコマンドラインでHTTPリクエストを送るためのツールで、webページの情報を取得できる
    ```bash
        curl -v https://google.com
    ```

    接続の確立
    ```bash
        * Host google.com:443 was resolved.
        * IPv6: 2404:6800:4004:80a::200e
        * IPv4: 142.250.199.110
        *   Trying 142.250.199.110:443...
        * Connected to google.com (142.250.199.110) port 443
    ```
    - DNS解決：  
        `google.com`がIPv4(142.250.199.110)とIPv6(2404:6800:4004:80a::200e)に解決され、IPv4アドレスへの接続が試みられている。
    
    - 接続確立：
        ポート 443(HTTPSの標準ポート)で、`google.com`に正常に接続された。
    ---

    #### 2. TLSハンドシェイク  
    ```bash
        * TLSv1.3 (OUT), TLS handshake, Client hello (1):
        * TLSv1.3 (IN), TLS handshake, Server hello (2):
        * TLSv1.3 (IN), TLS handshake, Certificate (11):
        * TLSv1.3 (IN), TLS handshake, Finished (20):
        * SSL connection using TLSv1.3 / TLS_AES_256_GCM_SHA384
    ```    
    - TLSハンドシェイク：  
        TLS1.3が使われて、クライアントとサーバー間で安全な通信が確立された。
        - `Client hello`と`Server hello`のやり取りが行われ、セキュリティパラメータが合意される  

        - サーバーからの証明書(`Certificate`)が提供され、それがクライアント側で検証された。

        - `TLS_AES_256_GCM_SHA384`という暗号化方式が使われて、データが安全に送受信されることが確認された。

    ---

    #### 3. サーバー証明書の検証
    ```bash
        * Server certificate:
        *  subject: CN=*.google.com
        *  start date: Aug 12 06:33:49 2024 GMT
        *  expire date: Nov  4 06:33:48 2024 GMT
        *  issuer: C=US; O=Google Trust Services; CN=WR2
        *  SSL certificate verify ok.
    ```

    - サーバー証明書の情報：  
        サーバー証明書が有効であり、ドメイン名`google.com`に対して正しいことが確認された(`SSL certificate verify ok.`)。

    - 証明書の発行者は`Google Trust Services`であり、証明書の有効期限は2024年11月4日(`Nov  4 06:33:48 2024 GMT`)。

    ---

    #### 4. HTTP/2リクエストの送信
    ```bash
        * using HTTP/2
        > GET / HTTP/2
        > Host: google.com
        > User-Agent: curl/8.5.0
        > Accept: */*
    ```

    - HTTP/2リクエスト：  
        暗号化されたセッションの上で、HTTP/2による`GET /`リクエストが送信された。

    ---

    #### 5. サーバーからのリダイレクト応答
    ```bash
        < HTTP/2 301
        < location: https://www.google.com/
        < content-type: text/html; charset=UTF-8
        < content-length: 220
    ```

    - HTTP 301リダイレクト：
        Googleのサーバーはリクエストに対してステータスコード`301 Moved Permanently`を返し、新しいURL`https://www.google.com/`へのリダイレクトを指示している。

    ---

    #### 6. レスポンスのHTML
    ```bash
        <HTML><HEAD><meta http-equiv="content-type" content="text/html;charset=utf-8">
        <TITLE>301 Moved</TITLE></HEAD><BODY>
        <H1>301 Moved</H1>
        The document has moved
        <A HREF="https://www.google.com/">here</A>.
        </BODY></HTML>
    ```

    - レスポンスのボディ：  
        HTMLで`301 Moved`のページが表示されており、リンク先として`https://www.googl.com/`が案内されている。

## 2. トランスポート層
### 役割

- データの信頼性と効率的な送信：  
    トランスポート層は、アプリケーション層から受け取ったデータを送信先のコンピュータに対して確実かつ効率的に届ける役割を持っている。  
    
    この層では、データが分割されて送信され、受信側で再構成される。  
    
    さらに、データが正しく届いたかどうかの確認や、エラーが発生した場合の再送信も行う。

- 通信の管理：  
    トランスポート層は、接続の確立や終了、エラーの検知・修正、データの順序の保証など、通信全体を管理する重要な役割を果たす。

### 主なプロトコル、規格
- **TCP(Transmission Control Protocol)：**  
    信頼性重視のプロトコルで、データが正しく届いたことを確認しながら通信を行う。  
    
    データが受信されると「受信確認応答(ACK: Acknoeledgment)」が送られ、データが欠落したり、順序が間違っていたりした場合には再送信が行われる。  
    
    これにより、データの順番や完全性が保証されるため、信頼性の高い通信が可能になる。   
    
    HTTP(80番)、HtTPS(443番)、SMTP(25番)、POP3(110番)など、多くのアプリケーションプロトコルがTCPを使っている。

- **UDP(User Datagram Protocol)：**  
    スピード重視のプロトコルで、データの到達確認を行わずに受信側がデータを失ってもそのまま通信が続く。  
    
    このプロトコルは、リアルタイム性が重視される用途、例えばビデオストリーミングやオンラインゲームなどで利用されることが多い。  
    
    データの完全性や順序を保証しないため、TCPに比べて通信速度が速いが信頼性は低い。  
    
    DNS(53番)、DHCP(67/68番)などのプロトコルがUDPを使っている。

### 具体的なプロセス例
- ### **TCPの動作と通信の流れ**  
    `curl`でリクエストを送ってその通信を`tcpdump`でパケットをキャプチャし、通信の流れを確認してみる

    #### 1. リクエストの送信とSYNパケット  
    ``` bash
    07:55:00.592941 IP x.x.x.x.41604 > nrt13s71-in-f14.1e100.net.http: Flags [S], seq 2870245486, win 64240, options [mss 1460,sackOK,TS val 1662956870 ecr 0,nop,wscale 7], length 0
    ```
    - 07:55:00.592941：  
        パケットがキャプチャされた時刻で、パケットの送受信のタイミング確認に使用されている。

    - IP x.x.x.x.41604：  
        送信元のIPアドレス(`x.x.x.x`： 個人情報の為マスク加工)とポート番号(`41604`)。  
        ここでは、送信元のクライアント情報が記載。

    - nrt13s71-in-f14.1e100.net.http：  
        送信先のホスト名(`nrt13s71-in-f14.1e100.net`)とポート番号(`http`は80番ポートを表す)。  
        ここでは、GoogleのHTTPサーバーに向けた通信を表している。

    - Flags [S]：  
        フラグ`S`は「SYN: SYNchronize packet」を意味し、３ウェイハンドシェイクの最初の段階であり、TCPの接続開始を示している。

    - seq 2870245486：  
        送信元がこの通信で最初に送るデータのシーケンス番号。  
        この番号から送られたパケットがどの順番に処理されるのかが決まる。

    - win 64240：  
        送信元のウィンドウサイズ。  
        クライアントが一度に受信できる最大データ量は64240バイトであることを示している。

    - options []：  
        - `mss 1460`：  
            最大セグメントサイズ(MSS: Maximum Segment Size)。  
            この通信で一度に送信できるデータの最大サイズが1460バイトであるということを表している。
        
        - `sackOK`：  
            セグメントの欠落が発生した場合に、Selective Acknowledgment(SACK)が使えることをしめしている。

        - `TS val 1662956870 ecr 0`：  
            タイムスタンプとその応答(エコー)。

    - length 0：  
        パケットのデータ長が0バイトであること。  
        SYNパケットは接続の確立だけなので、データは含まれていないため。

    ---

    #### 2. SYN-ACK応答
    ``` bash
    07:55:00.617883 IP nrt13s71-in-f14.1e100.net.http > x.x.x.x.41604: Flags [S.], seq 3714388618, ack 2870245487, win 65535, options [mss 1412,sackOK,TS val 2446101419 ecr 1662956870,nop,wscale 8], length 0

    ```
    - Flags [S.]：  
        `SYN`と`ACK`の両方がセットされていることを示している。  
        サーバーが接続要求を受け入れ、ACKで応答している。

    - seq 3714388618：  
        サーバーが使うシーケンス番号。  
        サーバー側も送信データの順序を管理する。

    - ack 2870245487：  
        ACK番号。  
        クライアントが送ったSYNパケットに対する確認番号で、「次に期待するデータがシーケンス番号2870245487から始める」という意味。

    - win 65535：  
        サーバー側のウィンドウサイズ。  
        サーバーが一度に受信できる最大データ量は65535バイトであることを示している。
    ---

    #### 3. ACKパケット通信
    ``` bash
    07:55:00.617969 IP x.x.x.x.41604 > nrt13s71-in-f14.1e100.net.http: Flags [.], ack 1, win 502, options [nop,nop,TS val 1662956895 ecr 2446101419], length 0
    ```
    - Flags [.]：  
        ACKパケットで、接続の確立が完了したことを示している。

    - ack 1：   
        クライアントがサーバーから送られたデータを全て確認し、次のデータを待っていることを示している。

    ---

    #### 4. HTTP GEtリクエストの送信
    ``` bash
    07:55:00.618161 IP x.x.x.x.41604 > nrt13s71-in-f14.1e100.net.http: Flags [P.], seq 1:74, ack 1, win 502, options [nop,nop,TS val 1662956895 ecr 2446101419], length 73: HTTP: GET / HTTP/1.1
    ```
    - Flags [P.]：  
        Pushフラグで、すぐに処理されるべきデータを示している。

    - seq 1:74：  
        クライアントからサーバーに送られるデータのシーケンス番号の範囲。  
        ここでは1から74までのでーた(73バイト(length 73))が送信されている。

    - HTTP: GET / HTTP/1.1：  
        クライアントが送っているHTTPリクエストの一部。  
        この部分がリクエストの内容。

    ---

    #### 5. ACK応答
    ``` bash
    07:55:00.641619 IP nrt13s71-in-f14.1e100.net.http > x.x.x.x.41604: Flags [.], ack 74, win 256, options [nop,nop,TS val 2446101442 ecr 1662956895], length 0
    ```
    - ack 74：  
        サーバーがクライアントからのデータを全て受け取ったことを確認し、受け取ったデータのシーケンス番号に対応するACK番号が返される。

    ---

    #### 6. HTTPレスポンスの送信
    ``` bash
    07:55:00.681504 IP nrt13s71-in-f14.1e100.net.http > x.x.x.x.41604: Flags [P.], seq 1:774, ack 74, win 256, options [nop,nop,TS val 2446101481 ecr 1662956895], length 773: HTTP: HTTP/1.1 301 Moved Permanently
    ```
    - Flags [P.]：  
        サーバーからのHTTPレスポンスが含まれている。  
        Pushフラグが立っていて、すぐにクライアントにデータが送られている。

    - seq 1:774：  
        773バイト(length 773)のデータがサーバーからクライアントに送信されている。

    - HTTP: HTTP/1.1 301 Moved Permanently：  
        サーバーからのレスポンスで、`301 Moved Permanently`は、リダイレクトを示している。

    ---

    #### 7. TCP接続の終了(FINパケット)
    ``` bash
    07:55:00.681731 IP x.x.x.x.41604 > nrt13s71-in-f14.1e100.net.http: Flags [F.], seq 74, ack 774, win 501, options [nop,nop,TS val 1662956958 ecr 2446101481], length 0
    ```
    - Flags [F.]：  
        クライアントがTCP接続の終了を要求するためにFINパケットを送信している。  
        FINパケットはTCP接続の片側が終了することを示し、もう一方からもFINパケットが返されると接続が完全に終了する。
    
    ---

- ### **UDPの動作と通信の流れ**
    DNSサーバーに問い合わせを行い、情報を取得することができる`dig`コマンドを使って、GoogleのDNSサーバーに対してクエリを送り、UDPの動作を確認する。

    #### 1. DNSクエリ
    ``` bash
    # 送信パケット
    12:14:01.947888 IP x.x.x.x.39386 > dns.google.domain: 11558+ [1au] A? google.com. (51)

    # 応答パケット
    12:14:01.984787 IP dns.google.domain > x.x.x.x.39386: 11558 1/0/1 A 142.250.207.110 (55)
    ```
    - 送信パケット：  
        - `x.x.x.x.39386`(クライアント側)から`dns.google.domain`(GoogleのDNSサーバーのポート53)へ送信。

        - DNSクエリとして、`google.com`のIPアドレス(Aレコード)を求めている。  
          [1au]は追加データが含まれていることを示している。
        
        - データ長は51バイト。
    
    - 応答パケット
        - GoogleのDNSサーバー(`dns.google.domain`)がクエリに応じて返してきている、

        - `11558 1/0/1 A 142.250.207.110`は、1つの回答として、`google.com`のIPアドレス`142.250.207.110`が返されていることを示している。

        - データ長は55バイト

    #### 2. NTP(Network Time Protocol)
    ``` bash
    # 送信パケット
    12:14:04.882118 IP 172.23.236.29.55836 > prod-ntp-4.ntp4.ps5.canonical.com.ntp: NTPv4, Client, length 48
    
    # 応答パケット
    12:14:05.118962 IP prod-ntp-4.ntp4.ps5.canonical.com.ntp > 172.23.236.29.55836: NTPv4, Server, length 48
    ```
    - 送信パケット:  
        - `x.x.x.x.55836`(クライアント側)から`prod-ntp-4.ntp4.ps5.canonical.com.ntp`(CanonicalのNTPサーバー、ポート123)に送信されている。

        - NTPのバージョン4(`NTPv4`)のクライアントリクエストを送信して、時間を同期させようとしている。

    - 応答パケット：
        - NTPサーバーから応答が返されている。  
          `NTPv4, Server, length 48`は、NTPサーバーからの応答であり、クライアントに現在の時間情報を提供している。

        - データ長は48バイト

## 3. インターネット層
### 役割

- ルーティングとアドレッシング：  
    インターネット層の主要な役割はデータを送信先まで届けるために、適切なルートを選択肢・アドレスの割り当てを行う。   
    例えば、データがインターネットのどこかにある特定のサーバーに届くために、どの経路を通るかを決める役割と持っている。

- 論理アドレスの使用：  
    インターネット層では**論理アドレス**を使って、各デバイスを特定する。  
    例えば、IPアドレスがこれに該当。  
    論理アドレスは、物理的な場所に依存せず、データが正しい場所に届くようにルーティングされる。

- パケットの分割と再構成：    
    大きなデータを送る場合、インターネット層ではデータを**パケット**と呼ばれる小さな単位に分割し、それぞれのパケットがネットワークを通じて送信される。  
    受信側では、パケットを再構成して元のデータに戻す。

### 主なプロトコル、規格

- **IP(Internet Protocol)：**  
    インターネット層の中核的なプロトコル。データの送信元と送信先を示す**IPアドレス**を利用して、データを適切な場所に届ける役割を持つ。

    - IPv4：  
        32ビットのアドレス空間で、通常`142.251.42.142`のような形式で表される。  
        限られたアドレス空間なので現在は枯渇してきている。

    - IPv6：  
        128ビットのアドレス空間で、`2404:6800:4004:827::200e`のように非常に多くのアドレスを扱える。  
        IPv4の後継。

- **ICMP(Internet Contorol Message Protocol)：**  
    エラーメッセージやネットワーク状態の確認を行うためのプロトコル。  
    `Ping`コマンドを使ってネットワークの疎通確認を行うときにICMPを使っている。  
    ICMPはエラーメッセージだけでなく、`traceroute`などのネットワーク経路確認でも利用され、パケットの移動ルートを追跡することができる。

- **ARP(Address Resolution Protocol)：**  
    IPアドレスを基に、同一ネットワーク上にあるデバイスの物理アドレス(MACアドレス)を取得するためのプロトコル。  
    例えば、ローカルネットワークで`192.168.0.10`というIPアドレスを持つ機器のMACアドレスを調べるために使用される。  
    ARPは一度解決されたMACアドレスをARPキャッシュに保存し、次回から同じIPアドレスに対してリクエストを送らずに済むようになっている。

### 具体的なプロセス例
- ### **ICMPの動きの確認**  
    実際に存在しないIPアドレスに`ping`を送ることで、ICMPの`Destination Host Unreachable`エラーを確認してみる。
    ```bash
    ping -c 4 192.168.1.50
    ```
    #### 結果
    ``` bash
    PING 192.168.1.50 (192.168.1.50) 56(84) bytes of data.
    From x.x.x.x icmp_seq=1 Destination Host Unreachable
    From x.x.x.x icmp_seq=2 Destination Host Unreachable
    From x.x.x.x icmp_seq=3 Destination Host Unreachable
    From x.x.x.x icmp_seq=4 Destination Host Unreachable
    ```
    - 結果として、`icmp_seq=1`から`icmp_seq=4`までの全てのリクエストに対して、ホストが到達不可能であることが通知されている。  
    `x.x.x.x`の部分は、pingを送信したネットワークデバイス(通常はルーターやゲートウェイ)のIPアドレスが表示される。